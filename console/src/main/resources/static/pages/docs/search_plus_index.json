{"./":{"url":"./","title":"Introduction","keywords":"","body":"介绍什么是服务编排适合做什么？整体流程功能图介绍 什么是服务编排 微服务时代，产生了大量的服务，如何基于现有服务再去开发一个新的服务？ 一般的，做服务聚合需要如下步骤： 收集接口信息 参数转换：将请求入参转换为各个接口的入参信息 响应结果聚合：将不同步骤的响应结果再加工，加工后返回到前端 本地测试 部署到线上测试 这个过程会有哪些问题？ 会产生很多边缘性代码：比如想要调用rpc服务，你必须引入相关的jar包、配置rpc调用者等信息，然后才可以开始去编写实际的代码 不够灵活：每次编排后都需要重新到服务器去发布 服务编排能解决什么？ 开箱即用：只需要将接口信息以及参数转换信息录入好，后续的任务执行都交给编排系统 一键发布：编排好的服务一键发布到线上 适合做什么？ 前端 一个页面调用多个接口时，可以编排好返回聚合结果，提高页面数据的加载速度 移动设备计算能力有限，可以把数据计算或业务处理逻辑放到服务端完成，加快页面响应 后端 替换应用层的聚合接口，减少应用层的胶水代码 数据转换和映射 协议转换:webservice、jsf接口前端不好直接调用，可以转换成http接口供前端调用 整体流程 功能图 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-07-11 14:37 "},"component/first-start.html":{"url":"component/first-start.html","title":"快速入门","keywords":"","body":"从0到1搭建一个应用开发接口录入录入city接口和province接口录入环境信息调试验证编排入参录入编排city步骤编排province步骤出参录入调试总结编排结果导入从0到1搭建一个应用 为了更直观的感受在线联调工具是怎么使用的，我们将带大家从0到1搭建一个项目。该项目的主要功能如下图所示： 如上图：有2个接口，分别是查询city接口和查询province接口，现在需要将2个接口合并成一个新的接口 查询city接口为 http://jap-mock-data.jd.local/city/{cityId} ,查询city返回结果里的province字段用来查询省份信息,你可以在浏览器里地址栏输入http://jap-mock-data.jd.local/city/11 查看结果 查询province接口为 http://jap-mock-data.jd.local/province/{province} 你可以在浏览器里地址栏输入http://jap-mock-data.jd.local/province/1 查看结果 开发 接口录入 录入city接口和province接口 出参格式分别为： 城市信息： { \"status\": 0, \"msg\": \"获取成功\", \"data\": { \"id\": 11, \"province\": 1, \"name\": \"石家庄\" } } 对应的录入界面如下： 省份信息: { \"status\": 0, \"msg\": \"获取成功\", \"data\": { \"id\": 1, \"name\": \"河北\" } } 录入环境信息 调试验证 分别调试city、province接口，city id传入11,province id传入1，验证没有问题后，接口完成录入 编排 入参录入 进入编排页面，右键流程编排节点，录入入参cityId 编排city步骤 新增http步骤，并选择刚才录入的city方法，录入映射信息，映射信息为：${workflow.input.params.cityId}，意思是将流程的cityId属性映射到当前节点 编排province步骤 在city下面新增http步骤，选择刚才录入的province方法，录入映射信息，映射信息为:${steps.queryCity.output.body.data.province}，意思是将queryCity步骤的出参的http请求体的data节点下的province映射到当前province上 出参录入 右键流程编排，打开参数录入抽屉： 录入出参： { \"code\": 0, \"mesage\": \"获取成功\", \"data\": { \"cityId\": \"${workflow.input.params.cityId}\", \"cityName\": \"${steps.queryCity.output.body.data.name}\", \"provinceId\": \"${steps.queryCity.output.body.data.province}\", \"provinceName\": \"${steps.queryCity.output.body.data.province}\" } } 调试 保存流程编排，并在调试页面输入11，查询调用结果 总结 以上就完成了一个简单流程的编排工作,关于参数映射，你可以参考：参数映射 也可以看下熟悉下流程编排的基础概念：流程编排 也可以将刚才编排的结果导入到系统中实际体验一下，编排结果在下面 编排结果导入 整个流程编排结果如下，可以直接将此结果导入到流程编排里体验一下 {\"name\":\"流程编排\",\"type\":\"Program\",\"children\":[{\"id\":\"queryCity\",\"type\":\"http\",\"key\":\"6Mvhf7\",\"input\":{\"url\":\"/city/{id}\",\"method\":\"GET\",\"reqType\":\"form\",\"params\":[],\"headers\":[],\"path\":[{\"name\":\"id\",\"value\":\"${workflow.input.params.cityId}\",\"exprType\":\"expr\",\"type\":\"string\"}],\"body\":[],\"script\":null,\"preProcess\":null},\"output\":{\"headers\":[],\"body\":[{\"name\":\"root\",\"type\":\"object\",\"children\":[{\"name\":\"status\",\"type\":\"double\"},{\"name\":\"msg\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"object\",\"children\":[{\"name\":\"id\",\"type\":\"double\"},{\"name\":\"province\",\"type\":\"double\"},{\"name\":\"name\",\"type\":\"string\"}]}]}],\"script\":null},\"env\":\"线上环境\",\"endpointUrl\":[\"http://jap-mock-data.jd.local\"],\"successCondition\":null,\"taskDef\":{\"timeout\":0,\"fallbackStrategy\":\"stop\",\"fallback\":null},\"name\":\"city\",\"entityId\":34,\"interfaceID\":2},{\"id\":\"queryProvince\",\"type\":\"http\",\"key\":\"i69S2u\",\"input\":{\"url\":\"/province/{id}\",\"method\":\"GET\",\"reqType\":\"form\",\"params\":[],\"headers\":[],\"path\":[{\"name\":\"id\",\"value\":\"${steps.queryCity.output.body.data.province}\",\"exprType\":\"expr\",\"type\":\"string\"}],\"body\":[],\"script\":null,\"preProcess\":null},\"output\":{\"headers\":[],\"body\":[{\"name\":\"root\",\"type\":\"object\",\"children\":[{\"name\":\"status\",\"type\":\"double\"},{\"name\":\"msg\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"object\",\"children\":[{\"name\":\"id\",\"type\":\"double\"},{\"name\":\"name\",\"type\":\"string\"}]}]}],\"script\":null},\"env\":\"线上环境\",\"endpointUrl\":[\"http://jap-mock-data.jd.local\"],\"successCondition\":null,\"taskDef\":{\"timeout\":0,\"fallbackStrategy\":\"stop\",\"fallback\":null},\"name\":\"province\",\"entityId\":35,\"interfaceID\":2}],\"tasks\":[{\"id\":\"queryCity\",\"type\":\"http\",\"key\":\"6Mvhf7\",\"input\":{\"url\":\"/city/{id}\",\"method\":\"GET\",\"reqType\":\"form\",\"params\":[],\"headers\":[],\"path\":[{\"name\":\"id\",\"value\":\"${workflow.input.params.cityId}\",\"exprType\":\"expr\",\"type\":\"string\"}],\"body\":[],\"script\":null,\"preProcess\":null},\"output\":{\"headers\":[],\"body\":[{\"name\":\"root\",\"type\":\"object\",\"children\":[{\"name\":\"status\",\"type\":\"double\"},{\"name\":\"msg\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"object\",\"children\":[{\"name\":\"id\",\"type\":\"double\"},{\"name\":\"province\",\"type\":\"double\"},{\"name\":\"name\",\"type\":\"string\"}]}]}],\"script\":null},\"env\":\"线上环境\",\"endpointUrl\":[\"http://jap-mock-data.jd.local\"],\"successCondition\":null,\"taskDef\":{\"timeout\":0,\"fallbackStrategy\":\"stop\",\"fallback\":null},\"name\":\"city\",\"entityId\":34,\"interfaceID\":2},{\"id\":\"queryProvince\",\"type\":\"http\",\"key\":\"i69S2u\",\"input\":{\"url\":\"/province/{id}\",\"method\":\"GET\",\"reqType\":\"form\",\"params\":[],\"headers\":[],\"path\":[{\"name\":\"id\",\"value\":\"${steps.queryCity.output.body.data.province}\",\"exprType\":\"expr\",\"type\":\"string\"}],\"body\":[],\"script\":null,\"preProcess\":null},\"output\":{\"headers\":[],\"body\":[{\"name\":\"root\",\"type\":\"object\",\"children\":[{\"name\":\"status\",\"type\":\"double\"},{\"name\":\"msg\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"object\",\"children\":[{\"name\":\"id\",\"type\":\"double\"},{\"name\":\"name\",\"type\":\"string\"}]}]}],\"script\":null},\"env\":\"线上环境\",\"endpointUrl\":[\"http://jap-mock-data.jd.local\"],\"successCondition\":null,\"taskDef\":{\"timeout\":0,\"fallbackStrategy\":\"stop\",\"fallback\":null},\"name\":\"province\",\"entityId\":35,\"interfaceID\":2}],\"taskDef\":null,\"input\":{\"headers\":[],\"params\":[{\"name\":\"cityId\",\"exprType\":\"expr\",\"type\":\"string\"}],\"reqType\":null,\"body\":[],\"preProcess\":null},\"output\":{\"headers\":[],\"body\":[{\"name\":\"root\",\"exprType\":\"expr\",\"type\":\"object\",\"children\":[{\"name\":\"code\",\"value\":\"0\",\"exprType\":\"expr\",\"type\":\"string\"},{\"name\":\"message\",\"value\":\"获取成功\",\"exprType\":\"expr\",\"type\":\"string\"},{\"name\":\"data\",\"exprType\":\"expr\",\"type\":\"object\",\"children\":[{\"name\":\"cityId\",\"value\":\"${workflow.input.params.cityId}\",\"exprType\":\"expr\",\"type\":\"string\"},{\"name\":\"cityName\",\"value\":\"${steps.queryCity.output.body.data.name}\",\"exprType\":\"expr\",\"type\":\"string\"},{\"name\":\"provinceId\",\"value\":\"${steps.queryCity.output.body.data.province}\",\"exprType\":\"expr\",\"type\":\"string\"},{\"name\":\"provinceName\",\"value\":\"${steps.queryProvince.output.body.data.name}\",\"exprType\":\"expr\",\"type\":\"string\"}]}]}],\"script\":null,\"empty\":false},\"failOutput\":{\"headers\":[],\"body\":[{\"name\":\"root\",\"exprType\":\"expr\",\"type\":\"object\",\"children\":[]}],\"script\":null,\"empty\":false}} Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-07-12 11:20 "},"component/interface_mng/http.html":{"url":"component/interface_mng/http.html","title":"http接口","keywords":"","body":"Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 14:21 "},"component/interface_mng/webservice.html":{"url":"component/interface_mng/webservice.html","title":"webservice接口","keywords":"","body":"Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 14:21 "},"component/interface_mng/jsf.html":{"url":"component/interface_mng/jsf.html","title":"jsf接口","keywords":"","body":"Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 14:21 "},"component/global/architecture.html":{"url":"component/global/architecture.html","title":"架构图","keywords":"","body":"架构架构 页面设计器的基本架构如下: Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 20:45 "},"component/components/core.html":{"url":"component/components/core.html","title":"基础概念","keywords":"","body":"流程编排核心概念流程输入流程输出任务任务要素值映射一个简单的示例类型说明JsonTypeMvelScript流程编排核心概念 流程编排主要分为输入、任务列表、输出其中，输入 对应编排接口的http请求，相当于需要用户传入的信息，输出 对应http响应，传给用户的信息。任务列表 里可以有很多子任务，它们会按顺序执行。在任务中，你需要通过表达式或者脚本将输入参数正确分配到每个步骤; 在任务执行过程中，前一个步骤的出参也可以作为后一个步骤的入参，通过这样，完成整个流程编排。 整个编排基于json描述，整体结构如下： { input:{// 定义输入结构 \"headers\":Array,// 请求头 \"body\": Array,// 请求体 \"reqType\": \"json|form\",// 请求类型 \"params\": Array }, \"output\":{ // 定义输入结构，同http接口管理 \"headers\":Array, \"body\":Array, \"script\":MvelScript // 脚本 }, \"failOutput\":{ // 定义输入结构，同http接口管理 \"headers\":Array, \"body\":Array, \"script\": MvelScript // 脚本 }, tasks:Array,//任务列表 } 流程输入 输入即为http输入，主要要素如下： 输入要素 描述 headers http请求头信息 body http请求body信息 params http query string 流程输出 出参分为正确的出参和错误的出参，正确的出参是每一个步骤都正确执行没有错误的输出，任意一个步骤执行失败会返回错误的出参。 通过${workflow.exception.message}获取异常信息，通过${workflow.exception.stepId}获取步骤id。详细信息可以参考异常处理 任务 任务是接口编排的核心，主要用来： 发起接口调用 进行数据加工 进行分支判断目前支持的任务有： 任务 描述 http步骤 用来发起http调用 webservice步骤 发起webservice调用 jsf调用 发起jsf调用 数据转换 用来进行数据加工、结果汇总 choose多分支选择 用来进行多分支判断 multicast并行执行 并行执行多个步骤，并将步骤的结果收集起来 任务要素 每个任务都有： id 任务id,在映射时，通过steps.xx引用某个步骤，其中xx为任务id input: 任务入参：不同的步骤实现不同，比如http步骤的入参有headers、body、params等，而webservice就只有xml报文体 output： 任务出参，不同步骤的出参也不太一样，比如http步骤有headers和body 编排时，需要将入参的值映射一下，然后在执行时，会将映射的值替换为实际的值，并发起调用。 每个步骤执行完成后其入参、出参可以被后续步骤所引用,引用方式为：steps.xx.input、steps.xx.output 目前支持表达式以及脚本来做参数映射，表达支持常量表达式和jsonpath表达式，具体参考json_expr表达式,脚本为mvel脚本，参考：mvel脚本 值映射 值映射用来加工数据，支持表达式及脚本，为了方便映射，提供一些变量可以使用： workflow :代指整个流程对象 steps： 执行步骤 一些常见的映射： # 获取入参请求头a的值： workflow.input.headers.a # 获取入参query a的值： workflow.input.params.a # 获取入参请求提 a.b的值： workflow.input.body.a.b # 获取http步骤queryCity请求头a的值： steps.queryCity.input.headers.a # 获取http步骤queryCity请求query a的值： steps.queryCity.input.params.a # 获取http步骤queryCity请求body a的值： steps.queryCity.input.body.a # 获取http步骤queryCity响应头的值： steps.queryCity.output.headers.a # 获取http步骤queryCity响应体的值： steps.queryCity.output.body.a # 在错误输出里获取异常信息 workflow.exception.message # 在错误输出里获取异常执行参数 workflow.exception.params 更详细的说明参考：数据映射 一个简单的示例 演示将2个http步骤的结果汇总到一起 { \"input\": { \"body\":[ { \"name\": \"root\", \"type\": \"object\", \"children\": [ { \"name\": \"id1\", \"type\": \"long\" },{ \"name\": \"id2\", \"type\": \"string\" } ] } ] }, \"tasks\": [ { \"id\": \"mul\", \"type\": \"multicast\", \"children\": [ { \"id\": \"queryHtml1\", \"type\": \"http\", \"endpointUrl\": [\"http://jap-mock-data.jd.local\"], \"input\": { \"url\": \"/html/{id}\", \"reqType\": \"json\", \"method\": \"get\", \"path\": [ { \"name\": \"id\", \"type\": \"string\", \"value\": \"${workflow.input.body.id1}\" } ] } },{ \"id\": \"queryHtml2\", \"type\": \"http\", \"endpointUrl\": [\"http://jap-mock-data.jd.local\"], \"input\": { \"reqType\": \"json\", \"method\": \"GET\", \"url\": \"/html/{id}\", \"path\": [ { \"name\": \"id\", \"type\": \"string\", \"value\": \"${workflow.input.body.id2}\" } ] } } ], \"output\": { \"body\": [{ \"name\": \"root\", \"type\": \"object\", \"children\": [ { \"name\": \"code\", \"type\": \"string\", \"value\": \"0\" },{ \"name\": \"message\", \"type\": \"string\", \"value\": \"获取成功\" },{ \"name\": \"data\", \"type\": \"array\", \"children\": [{ \"name\": \"resp1\", \"type\": \"object\", \"value\": \"${steps.queryHtml1.output.body.data}\" },{ \"name\": \"resp2\", \"type\": \"object\", \"value\": \"${steps.queryHtml2.output.body.data}\" }] } ] }] } } ] } 上面的逻辑大概等同于代码： var result1 = queryHtml1(workflow.input.body.id1); var result2 = queryHtml2(workflow.input.body.id2); return { \"code\":\"0\", \"message\":\"获取成功\", \"data\":[result1.output.body.data,result2.output.body.data] } 有一个聚合步骤，然后将2个步骤的内容汇总到一起 类型说明 JsonType jsonType用来描述json、xml数据的结构，类似json schema JsonType分为SimpleJsonType、ObjectJsonType和ArrayJsonType SimpleJsonType的结构示例如下： {name:\"sid\",type:\"integer|long|double|string|boolean\",required:\"true|false\",desc:null,value:\"xxx\",\"exprType\": ''} ObjectJsonType的类型如下： {name:\"user\",type:\"object\",required:\"true|false\",children:Array,value:\"xxx\"} ArrayJsonType的类型如下： {name:\"user\",type:\"array\",required:\"true|false\",children:Array,value:\"xxx\"} 注意事项： value属性只有接口编排的时候才会用 exprType为表达式类型，可以取值：expr,script ，分别是表达式、脚本 其他字段说明： name : 名称 type：类型，可以为 object|array|integer|long|double|string|boolean required:是否必填 children:子节点 desc:描述 value: 值 MvelScript mvel脚本，具体参考：mvel脚本 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-07-22 11:04 "},"component/":{"url":"component/","title":"步骤列表","keywords":"","body":"Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-29 18:23 "},"component/components/http.html":{"url":"component/components/http.html","title":"http步骤","keywords":"","body":"http步骤http输入input.preProcess预处理脚本值映射input.script 数据加工input.successConditiontaskDefhttp步骤 http步骤的基本要素如下： { \"id\": string, \"type\":\"http\", \"input\":{ \"method\":\"GET|POST|OPTIONS|...\", \"url\":string, // 比如/user/{id} {id}表示路径参数，需要在path属性里体现 \"path\":Array, // path参数里只有url里存在占位符的参数，如{type} \"params\":Array, // query参数 \"headers\":Array, // headers参数 \"preProcess\": MvelScript, // 预处理脚本,可以用来做参数处理、数据校验 \"script\": MvelScript, //数据处理脚本 \"reqType\":\"form|json\", // 请求类型 \"body\" :Array// 请求体 }, \"endpointUrl\": Array, //调用环境对应的接口地址列表,endpointUrl和url拼接形成一个完整的url \"successCondition\":MvelExpression,// 本次请求成功的条件，是mvel表达式 \"taskDef\": { \"timeout\": 1000, // 超时时间 \"fallbackStrategy\": \"stop|continue\",//失败策略 继续活着停止 \"fallback\": {} // 失败后的返回值 }, \"output\":{ \"headers\":Array, // 响应头信息 \"body\":Array,// 响应体信息 \"script\": MvelScript } } http输入 input.preProcess预处理脚本 预处理脚本用来校验数据以及预处理数据，Mvel脚本里有如下变量： workflow 工作流 steps 步骤列表 input 当前步骤的http input对象比如，校验数量和单价，并且把总价设置到attr上if(workflow.input.body.price 上面的步骤将total属性设置到attr上，在数据映射时，可以通过input.attrs.total获取到加工的值 值映射 input.path、input.params、input.headers、input.body等都支持值映射，同时支持表达式以及脚本在表达式里支持的变量有： workflow steps input 当前http input对象，可以通过input.attrs.xx 获取预处理脚本加工的数据 input.script 数据加工 input.script用来做数据加工，当指定了脚本的话，值映射不会生效。input为http input对象，比如，你可以这样写： input.params = { \"id\":workflow.input.params.id }; input.headers = { \"token\":\"fdsfds-fkfkds\", \"name\":workflow.input.params.id }; input.body = { \"name\":workflow.input.params.id, \"desc\":steps.prevStep.output.body.desc } input.url = \"/user/\"+workflow.input.params.id input.successCondition 用来判断执行是否成功。一般的，当前步骤执行成功才可以继续往下执行，但是如何判断步骤执行成功呢？默认情况下，通过http状态码来判断，http状态码非2xx的认为是失败。但是有些情况下，执行失败也会返回200，这个时候需要通过表达式来判别是否执行成功，比如： output.body.status==0; 这样，当执行失败了，就可以提前终止整个步骤的执行 taskDef 任务定义规定了与本次执行有关的一些配置 timeout： 超时时间，超时后会终止当前任务,返回失败 fallbackStrategy： 失败后是否继续执行，若配置为continue则继续执行 fallback 失败后的响应值，为json，比如可以为{\"code\":0,message:\"执行成功\"} 。字符串json也会被当做json： \"{\\\"code\\\":0,message:\\\"执行成功\\\"}\"，也可以为纯字符串，比如：0 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-07-07 19:09 "},"component/components/webservice.html":{"url":"component/components/webservice.html","title":"webservice步骤","keywords":"","body":"webservice步骤webservice的入参、出参信息webservice步骤返回值webservice步骤 webservice步骤用来编排webservice服务，目前支持wsdl1.1 ，整体配置如下： { \"id\": string, // 步骤id \"type\":\"http2ws\", \"input\":{ \"url\": \"\", // webservice调用路径 \"schemaType\": JsonType }, \"opName\": string,// 操作名称 \"endpointUrl\": Array, //调用环境对应的接口地址列表 \"taskDef\": { \"timeout\": 1000 // 超时时间 }, output:{ schemaType:JsonType } } 正常情况下，webservice的入参是xml格式，但是现在前端去构造xml很不方便，因此，会将webservice的入参、出参都转换为json,input.schemaType、output.schemaType就负责描述webservice的入参以及出参结构。 比如，针对soap 输入报文: ? ? 对应的json描述为： { \"name\": \"Envelope\", \"namespacePrefix\": \"soapenv\", \"attrs\": { \"xmlns:soapenv\": \"http://schemas.xmlsoap.org/soap/envelope/\", \"xmlns:ser\": \"http://service.workflow.jd.com/\" }, \"type\": \"object\", \"children\": [{ \"name\": \"Header\", \"namespacePrefix\": \"soapenv\", \"type\": \"object\", \"children\": [] }, { \"name\": \"Body\", \"namespacePrefix\": \"soapenv\", \"type\": \"object\", \"children\": [{ \"name\": \"saveRole\", \"namespacePrefix\": \"ser\", \"type\": \"object\", \"children\": [{ \"name\": \"roleInfo\", \"type\": \"object\", \"children\": [ { \"name\": \"id\", \"type\": \"long\" }, { \"name\": \"roleName\", \"type\": \"string\" } ] } ] } ] } ] } 通过json来描述xml的结构有什么好处？ 可以看到，xml的结构比较冗长，比如：soapenv:Envelope、soapenv:Header、soapenv:Body等固定节点完全可以去掉，我们可以简化入参，只映射需要映射的。比如可以在saveRole的映射表达式为：workflow.input.body,这样 只需要输入{id:xx,roleName:xx}，就可以完成整个webservice的入参映射 webservice接口也可以作为http接口来管理 webservice的入参、出参信息 webservice入参、出参对应WebServiceInput、WebServiceOutput，在后续步骤可以通过steps.xx.input、以及steps.xx.output来引用这2个对象 class WebServiceInput{ String body; // xml请求体 Map attrs;// 额外属性 } /** webservice步骤的输出，通过steps.xxx.output引用，其中，xxx是webservice步骤 */ public class WebServiceOutput extends HttpOutput{ /* webservice响应头，通过steps.xxx.output.headers引用 */ Map headers; /* webservice的响应体 */ Object body; /** http原始响应：针对webservice步骤，可以通过steps.xxx.output.response.body 获取到原始的响应xml信息 */ HttpResponse response; public static class HttpResponse { int status; Map headers = new HashMap<>(); Object body; } /** 错误的详细信息：通过steps.xxx.output.error引用 */ WebServiceError error; public static class WebServiceError { String faultCode; String faultActor; String faultString; FaultDetail detail; public static class FaultDetail{ String name; Object desc; } } webservice步骤返回值 webservice执行完成后，soap:Header、soap:Body 会被转换为output.headers、output.body参数，也就是会将xml转换为json，举例说明： 针对： 123 1 admin header会被转换为： {\"token\":123} body被转换为： {\"return\":{\"id\":1,\"roleName\":\"admin\"}} 可以看到，body的ns2:queryRoleResponse节点被跳过了，这是因为queryRole的名称与webservice的opName一致，如果你熟悉webservice开发的话，webservice有一个 @SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)配置，这里的parmeterStyle可以为SOAPBinding.ParameterStyle.BARE或者SOAPBinding.ParameterStyle.WRAPPED，跳过op节点是为了确保这2个样式下映射的值一致。 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 20:45 "},"component/components/jsf.html":{"url":"component/components/jsf.html","title":"jsf步骤","keywords":"","body":"Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 14:21 "},"component/components/choose.html":{"url":"component/components/choose.html","title":"choose步骤","keywords":"","body":"分支选择步骤when表达式分支选择步骤 分支选择用来做多分支判断，只有满足指定条件，才会继续执行后续步骤 { \"id\": string, type:\"choose\", children:[ { when:MevlScript,// 判断条件，满足条件才会执行children步骤 children:Array // when匹配后执行此步骤 }, { when:MevlScript, children:Array // 匹配后执行此步骤 }, { // 默认执行的逻辑 children:Array } ] } choose的多个分支间的执行逻辑是互斥的，即先判断第一个条件，条件满足后停止后续判断，否则会判断后续的条件，直至所有条件都判断完成。 when表达式 when表达式用来做判断，必须返回boolean类型，可以用workflow、steps2个变量。关于mvel脚本，详细参考脚本配置 举例说明： workflow.input.params.id==1; Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 20:45 "},"component/components/transform.html":{"url":"component/components/transform.html","title":"转换步骤","keywords":"","body":"数据转换脚本body映射script映射输出数据转换脚本 数据转换步骤用来做数据收集、数据加工 数据转换的格式如下： { \"id\": string, // 步骤id \"type\":\"transform\", output:{ body:Array, // 收集结果 \"script\": MvelScript // 使用脚本来收集结果，指定了script的话body里的映射不再生效 } } body映射 映射时可以使用workflow、steps变量，映射的具体规则参考表达式、脚本 script映射 script是mvel脚本，内置workflow、steps变量,比如，可以这样写： output.body = { \"id\":workflow.input.params.id, \"name\":steps.queryUser.output.body.name // 获取queryUser步骤结果的body里的name }; 输出 transform步骤只会输出body，没有headers输出，后续步骤只能引用steps.xx.output.body来引用数据转换步骤的结果。 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 20:45 "},"component/components/multicast.html":{"url":"component/components/multicast.html","title":"并行执行步骤","keywords":"","body":"并行执行步骤并行执行步骤 并行执行步骤用来将多个普通步骤并行执行的，并将执行结果汇总到一起，其结构如下： { \"id\": string\",// 步骤id \"type\":\"multicast\", \"children\":Array, // 子节点 output:{ // 用来做值收集 body:Array, \"script\": \"\"// 转换脚本 } } children为子步骤，可以嵌套别的步骤。output的配置同数据转换步骤,这里不再赘述 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 20:45 "},"component/data-mapping.html":{"url":"component/data-mapping.html","title":"数据映射","keywords":"","body":"数据映射映射规则workflowstepshttp步骤webservice步骤转换步骤参数预处理及脚本加工脚本映射数据映射 数据映射是流程编排里最重要的组成部分，数据映射可以用来： 将入参映射到不同的接口里 将接口数据收集到一起 举例说明： 可以通过${workflow.input.params.id}引用流程入参query里的id属性。 数据映射分为表达式映射以及mvel脚本,如下图所示，在参数映射里选择具体的映射信息。 表达式为json path表达式或者常量，被${}包裹的是json path表达式，其他的是常量 ，json path表达式可以拼接，比如:${workflow.input.params.id}_${workflow.input.params.name}.表示将id、name用_拼接到一起。 脚本为mvel脚本,不需要任何符号包裹，比如可以通过 workflow.input.params.id 引用到query参数的id，mvel脚本和表达式的具体规则参考下面的说明 映射规则 根据基础概念里的说明，你应该已经知道了流程分为入参、任务列表、出参因此，我们根据这些概念抽象出2个变量，分别为workflow、steps，他们分别对应流程定义和任务列表，他们的结构如下： workflow input params ： query参数信息，map类型 body ： 请求体信息，json类型的请求体会自动解析，因此可以通过workflow.input.body.data.xxx.xxx 去继续获取body里的信息,任意类型 headers ：请求头信息,map类型 attrs ： 用来临时存储局部变量，mvel脚本加工的数据可以通过workflow.input.attr(\"xx\",xx) 临时存储，通过workflow.input.attrs.xx取值， map类型 output headers ： 响应头信息，可以通过workflow.output.headers.xxx引用具体的属性 ， map类型 body ：响应体信息，json类型的也会自动被解析,任意类型 exception message ： 执行出异常后的描述信息 ,string类型 stepId ： 发送错误的步骤id ,string类型 params: 异常具体的参数 ， map类型 steps steps为任务列表，一个任务执行完成了，就可以引用该步骤的入参和出参信息，分别通过input和 output来引用,他们的在不同任务下略有不同，但一般来说，input和output都有body信息，对应请求体。 http步骤 http步骤有入参和出参信息 input params ： query参数信息 ， map类型 body ： 请求体信息，json类型的请求体会自动解析，因此可以通过workflow.input.body.data.xxx.xxx 去继续获取body里的信息 ,任意类型 headers： 请求头信息 ， map类型 url ： 请求url信息，不含域名信息,string类型 attrs ：入参里用来存储加工的数据，通过steps.xx.input.attr(xx,xx)设值，通过steps.xx.input.attrs.xxx取值， map类型 output headers： 响应头信息 ， map类型 body ：响应体信息,任意类型 attrs ： 响应里用来临时存储数据的地方，通过steps.xx.output.attr(xx,xx)设值，通过steps.xx.input.attrs.xx取值 ， map类型 status： http响应status，int类型 webservice步骤 input body ：soap xml请求体 ,任意类型 attrs ， map类型 output headers： webservice soap xml的Header属性,被转换为json了 ， map类型 body ： webservice soap xml的Body属性，被转换为json了,任意类型 attrs 临时存储数据的变量 ， map类型 status ：http响应status，int类型 转换步骤 转换步骤只有出参output output headers 目前为空 body 收集到的请求体信息 ,任意类型 attrs 临时存储加工数据的地方，通过steps.xx.output.attr(xx,xx)设值，通过通过steps.xx.output.attrs.xx取值 ， map类型 参数预处理及脚本加工 参数预处理用来校验数据以及加工入参。上下文存在input变量，比如在http步骤，可这样写： if(workflow.input.params.price 脚本映射 入参、出参映射支持脚本，在入参脚本里有input变量，出参脚本里有output变量。出参脚本只有在响应正常的情况下才能被执行。 input结构和上面描述的结构一致，因此，在http入参映射里你可以这样写 input.params={ \"a\":workflow.input.params.id }; input.body=[{ \"a\":workflow.input.params.id }]; input.headers={ \"a\":workflow.input.params.id }; input.url = \"/province/123\"; webservice步骤也类似 出参也类似，比如针对转换步骤，可以这样写： output.body = { \"token\":steps.http.output.body.token }; 更多信息参考脚本、表达式 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-07-12 11:23 "},"component/components/script.html":{"url":"component/components/script.html","title":"脚本","keywords":"","body":"数据脚本整体对象结构数据加工函数日期时间转换json解析json序列化xml解析渲染jsonpath模板字符串根据json构造xmlxml xpath选择节点类型转换当前日期使用jsonPath获取数据注意事项数据脚本 数据脚本用来做数据验证、加工数据，目前支持mvel脚本为了方便进行数据加工，系统内置了一些变量以及工具函数来辅助进行数据加工 workflow 工作流对象，里面有输入、输出、以及异常信息 steps 步骤对象 除了变量以及工具函数，java.util、以及java.lang包下面的工具、集合都可以直接使用，比如： var a = new ArrayList(); a.add(1); a; 整体对象结构 workflow和steps的结构参考数据映射 数据加工函数 utils工具类用来做数据转换，目前支持： 日期格式转换 xml解析 xml xpath选择 类型转换 获取当前时间 字符串解析为json & json序列化为字符串 通过jsonpath获取数据 日期时间转换 String formatDate(String date,String sourcePattern,String targetPattern); 转换基于java的SimpleDateFormat,比如：2020-01-01对应的pattern为yyyy-MM-dd 下面是一些示例： utils.formatDate(\"2020-01-01\",\"yyyy-MM-dd\",\"yyyy年MM月dd日\") // 返回2020年01月01日 json解析 Object parseJson(String str) 将字符串解析为 utils.parseJson(\"{\\\"a\\\":1}\") //结果为{a:1} json序列化 String toJson(Object o) xml解析 将xml解析为json Map parseXml(String xml, String... arrayPaths) arrayPaths为数组节点的路径，默认所有的xml tag会被解析为对象，需要指定arrayPaths来指定数组节点的路径utils.parseXml(\"1\") // {\"a\":\"1\"} utils.parseXml(\"1\",\"/a\") // [{\"a\":\"1\"}] utils.parseXml(\"1\") // {\"a\":{\"b\":\"d\",\"#text\":\"1\"}} 渲染jsonpath模板字符串 渲染模板，template里的${}会被替换掉变量， String render(String templateString);：可用变量为workflow、stepsString render(String templateString,Map vars);，可用变量为vars。 utils.render(\"${workflow.input.params.id}\") // 1 这里假定id为1 utils.render(\"${id}\"，workflow.input.params) // 1 这里假定id为1 根据json构造xml 将json转换为xml,方法签名为：String jsonToXml(Map json)，#attr用来表示属性信息，既有属性又有内容时#text用来表示内容。 举例说明： utils.jsonToXml({a:1}); // 1 utils.jsonToXml({a:[1,2]}); // 12 utils.jsonToXml({a:[{b:1},{b:2}]}); // 112 utils.jsonToXml({a:{\"#attr\":{id:1},\"#text\":123}); // 123 xml xpath选择节点 选择字符串： *string xpathSelectString(String xml,String xpathExpression)选择一个节点 ： *string xpathSelectNode(String xml,String xpathExpression) 选择节点列表： *string xpathSelectNodeList(String xml,String xpathExpression) 类型转换 valueOf方法用来做类型转换。 IVariant valueOf(Object o); IVariant是变体类型，支持的方法如下： public interface IVariant { String toString(); // 转成字符串 String toString(String value); // 转成字符串,为空的时候返回value String toNullableString(); // 为空的时候返回null，\"\"也会返回空 boolean toBool(); // 转成boolean 类型 Boolean toBool(Boolean nullValue, Boolean defaultValue); // 转换为boolean类型，值为空时返回nullValue，否则为defaultValue Boolean toBool(Boolean defaultValue); // 转成boolean，转换失败的话 使用defaultValue默认值 char toChar(); // 转换为char Character toCharObject();//与char的区别是返回值可为空 Character toChar(Character defaultValue);// 转换为Charactor类型，转换失败会使用defaultValue默认值 int toInt(); Integer toIntObject(); Integer toInt(Integer defaultValue);// 转换为整形失败会使用defaultValue作为返回值 double toDouble(); Double toDoubleObject(); Double toDouble(Double defaultValue); // 转换失败使用defaultValue作为默认值 long toLong(); Long toLongObject(); Long toLong(Long defaultValue); // 转换失败使用defaultValue作为默认值 float toFloat(); Float toFloatObject(); Float toFloat(Float defaultValue); // 转换失败使用defaultValue作为默认值 Number toNumber(); Number toNumber(Number defaultValue); // 转换失败使用defaultValue作为默认值 Timestamp toTimestamp();//转换为时间戳 ,支持将Date、时间戳、Calendar、yyyy-MM-dd HH:mm:ss 格式的数据解析为时间戳 Timestamp toTimestamp(Timestamp defaultValue); // 转换失败使用defaultValue作为默认值 Date toDate(); //转换为日期类型 ,支持将Date、时间戳、Calendar、yyyy-MM-dd HH:mm:ss 格式的数据解析为日期 Date toDate(Date value); String toJson(); // 转为json字符串 List toCsvList(); // 将List或者以,分割的字符串转为列表 Set toCsvSet(); List toCsvList(List defaultValue); Set toCsvSet(Set defaultValue); List toList(); // 将数组、Iterable、以,分割的字符串、集合对象转为List List toList(List defaultValue); Collection toCollection(); // 将数组、Iterable、以,分割的字符串、集合对象转为集合 Collection toCollection(Collection defaultValue); Set toSet();// 将数组、Iterable、以,分割的字符串、集合对象转为Set Set toSet(Set defaultValue); Object[] toArray();//将集合转换为数组 Object[] toArray(Object[] defaultValue); String formatDate(String pattern); // 先转换为日期，再用SimpleDateFormat转换为日期 String formatNumber(String pattern); // 先转换为数字，在使用DecimalFormat转为为具体的格式 } 当前日期 获取当前日期：Date currentDate()、 获取当前日期字符串：String currentDate(String pattern) 使用jsonPath获取数据 Object jsonGet(Object o,String jsonPath) 注意事项 mvel脚本以;分割表达式，而不是换行，注意每个表达式后面加上;符号 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-07-19 12:48 "},"component/components/json_expr.html":{"url":"component/components/json_expr.html","title":"表达式","keywords":"","body":"数据表达式json path基础知识数据表达式 数据脚本用来加工数据，可以为常量或者表达式，表达式格式为${xxx}，非${}格式的输入会被认为是常量。 比如：1、a等都被认为是常量，${a}、${workflow.input.params.id}等被认为是表达式。表达式支持拼接，比如:${firstName}-${lastName} 会将firstName以及lastName通过-拼接到一起 表达式内部对应jsonpath表达式， jsonpath表达式内置workflow、steps2个变量，关于变量下具体有哪些值可以引用，参考脚本配置 举例说明： # 获取入参请求头a的值： workflow.input.headers.a # 获取入参query a的值： workflow.input.params.a # 获取入参请求提 a.b的值： workflow.input.body.a.b # 获取http步骤queryCity请求头a的值： steps.queryCity.input.headers.a # 获取http步骤queryCity请求query a的值： steps.queryCity.input.params.a # 获取http步骤queryCity请求body a的值： steps.queryCity.input.body.a # 获取http步骤queryCity响应头的值： steps.queryCity.output.headers.a # 获取http步骤queryCity响应体的值： steps.queryCity.output.body.a # 在错误输出里获取异常信息 workflow.exception.message # 在错误输出里获取异常执行参数 workflow.exception.params json path基础知识 参考文档：https://github.com/json-path/JsonPath Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 20:45 "},"example/advanced.html":{"url":"example/advanced.html","title":"调试","keywords":"","body":"Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-29 18:23 "},"component/deploy.html":{"url":"component/deploy.html","title":"发布","keywords":"","body":"一键导出代码一键导出代码 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 14:21 "},"faq.html":{"url":"faq.html","title":"常见问题","keywords":"","body":"常见问题常见问题 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-30 14:21 "},"CHANGELOG.html":{"url":"CHANGELOG.html","title":"更新日志","keywords":"","body":"Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-29 18:23 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"无代码低代码高代码无代码 开发应用，就像在 PowerPoint 里拖拉拽一样 低代码 开发应用，就像使用 Excel 一样，并且能够利用公式实现复杂的逻辑 高代码 开发应用，你能够直接写代码，没有任何限制 Copyright © 2022 京东零售-技术与数据中心-交易服务研发部-技术拓展组， powered by ABook修订时间： 2022-06-29 18:23 "}}